peerA:
  prompt_regex: "(?mi)^\\s*(?:claude|assistant|a:|>)\\s*$"   # Adjust to your PeerA CLI prompt if needed
  busy_regexes: []                                           # Usually not required for LLM shells
  idle_quiet_seconds: 1.0
  # Input & send: send on Enter; for robustness, send Enter twice after paste
  # Note: Ctrl-J inserts newline (no submit)
  post_paste_keys: ["Enter", "Enter"]
  input_mode: type                                           # paste | type (type can be more stable)
  compose_newline_key: "C-j"                                 # Use Ctrl-J to insert newline (no submit)
  send_sequence: "Enter"                                     # Final send key
  type_send_at_end: true                                     # Submit once after typing all lines
  chunk_lines: 14                                            # Break long messages by this number of lines
  chunk_delay_ms: 160                                        # Delay between chunks (ms)
  # Optional inbound suffix per source
  inbound_suffix:
    from_user: " Explore first: 2–3 quick options (1‑liners), ask 1 decisive Q; no patch yet; then hand baton to PeerB. ultrathink"
    from_peer: " Please review my work/opinion with first principles against our global goal; Synthesize: write a ≤6‑line Decision (or PCR+Hook) before next step; pick one cheapest discriminative Next. If nothing critical to add other than an pure ACK, stay silent and do not reply. ultrathink"
    from_system: " No pure ACK: add a new angle (risk/hook/smaller next) or steelman+counter in 1 line. ultrathink"
  # Optional NUDGE suffix (system [NUDGE] lines only)
  # e.g., " Read the oldest file and first echo ack: <seq> before processing"
  nudge_suffix: " Read oldest → act → output/reply → move to processed/ → next; if blocked, ask 1 decisive Q. ultrathink"
peerB:
  prompt_regex: "(?mi)^\\s*(?:codex(?:\\s*chat)?|>>>|>)\\s*$" # Adjust to your PeerB CLI prompt if needed
  busy_regexes:
    - "\\bRunning\\b"
    - "\\bExecuting\\b"
    - "\\bBuilding\\b|\\bCompiling\\b"
    - "\\bpytest\\b|\\bnpm\\s+test\\b|\\bjest\\b"
    - "\\b\\d{1,3}%\\b"
  idle_quiet_seconds: 1.5
  # Codex CLI: send on Enter; use Ctrl-J for newline (no submit)
  post_paste_keys: ["Enter"]
  input_mode: paste
  compose_newline_key: "C-j"
  send_sequence: "Enter"
  type_send_at_end: true
  chunk_lines: 12
  chunk_delay_ms: 180
  # NUDGE robustness (tmux): after sending a line, extra Enters and delay (ms)
  nudge_extra_enters: 0
  nudge_enter_delay_ms: 250
  # Optional inbound suffix per source
  inbound_suffix:
    from_user: " Do not act yet; wait for PeerA’s framing. Ask 1 decisive Q or propose a 2min micro‑experiment."
    from_peer: " No pure ACK: add a new angle (risk/hook/smaller next) or steelman+counter in 1 line; propose a Hook. If nothing critical to add other than an pure ACK, stay silent and do not reply."
    from_system: " End micro‑loops with 2‑line Reflect: what’s unclear + the single next check (with hook)."
  # Optional NUDGE suffix
  nudge_suffix: " Read oldest → act → output/reply → move to processed/ → next; keep changes small & evidential."
delivery:
  paste_max_wait_seconds: 6       # Max wait for idle before paste
  recheck_interval_seconds: 0.6   # Poll interval
  max_flush_batch: 3              # Max flush items per loop
  require_ack: false              # Treat mailbox events as ACK; do not require CLI echo ACK
  ack_mode: file_move             # ack_text | file_move; prefer file_move (CLI moves file to processed/)
  read_timeout_seconds: 8         # Max wait to read one response round
  ack_timeout_seconds: 40         # Mailbox ACK timeout threshold
  resend_attempts: 2              # Max resends after timeout (avoid noise)
  ack_require_mid: false          # Strictly require [MID: ...] echo to ACK? (default false)
  duplicate_window_seconds: 90    # De‑dup guard window
  # --- periodic self-check ---
  self_check_every_handoffs: 12   # Push a self-check after N handoffs (0=disable)
  self_check_text: |-
    [Self-check] Briefly answer (≤2 line each):
    1) Any drift from goal?
    2) What’s still unclear? Any new confusion created? Any better ideas?
    3) What was missed?
    4) As a human expert, what shall I do next?
    Continue only after answering.
  # --- mailbox pull + nudge mode ---
  mailbox_pull_enabled: true      # Enable inbox + NUDGE (instead of direct paste)
  inbox_dirname: "inbox"          # Inbox dir (relative to .cccc/mailbox/<peer>/)
  processed_retention: 200        # Max kept entries in processed/ (remove oldest beyond)
  nudge_resend_seconds: 90        # If inbox not ACKed for this interval, re‑NUDGE
  nudge_jitter_pct: 0.0           # Optional jitter (0.0~0.3) to avoid synchronized reminders
  soft_ack_on_mailbox_activity: false  # Consider later mailbox activity as soft ACK (default off)
  # Startup policy for leftover inbox files (resume | discard | archive)
  inbox_startup_policy: resume
  inbox_startup_prompt: true      # Prompt by default to avoid acting on stale files
  inbox_startup_prompt_timeout_seconds: 30
  inbox_startup_prompt_noninteractive_timeout_seconds: 0
  # --- lazy preamble ---
  lazy_preamble:
    enabled: true              # Prepend preamble (from prompt_weaver) to the first user message per peer

startup_wait_seconds: 12          # Wait time for first CLI prompt
startup_nudge_seconds: 10         # Max wait before activating NUDGE
console_echo: true                # Echo AI output in console (debug friendly; restart to apply)
tmux:
  alternate_screen_off: true      # Keep scrollback (turn off alt-screen)
commands:
  peerA: "claude --dangerously-skip-permissions"
  peerB: "codex --dangerously-bypass-approvals-and-sandbox"
delivery_mode:
  peerA: tmux     # Use tmux injection (more stable)
  peerB: tmux
